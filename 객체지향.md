- [x] ## 객체지향이란?


객체 지향 프로그래밍 언어는 컴퓨터 프로그래밍의 패러다임 중 하나로 각 명령어의 실행 순서를 기반으로 바라보는 절차지향과는 다르게 데이터와 이를 처리하는 루틴들을 하나의 독립된 객체로 바라보는 것이다.

* 따라서 규모가 큰 프로젝트에서 객체지향 프로그래밍 언어가 많이 사용된다.
* 기존에 만들었던 내용을 쉽게 상속하거나 재사용을 하는 것이 가능하다.
* 개발자가 코드를 만들며 발생하는 오류에 대해 생성자와 소멸자, 접근제어와 같은 내용들이 이러한 오류를 잡아준다.



#### 1. 객체와 클래스, 인스턴스

**객체**는 개별적으로 구분할 수 있는 실체를 의미한다. (사람, 통장계좌, 자동차, 학생, 버튼 등. 즉 주변 모든 것이 객체이다.)

* 객체는 자신 고유의 이름과 상태, 행동을 갖는다.
* 객체의 상태를 표현할 때 맴버변수라고 표현할 수 있으며, 객체의 행동을 메소드 혹은 맴버함수라고 표현한다.

**클래스**는 객체의 상태와 행동을 어떻게 만들지 결정하는 설계도(?)이다. 

어떠한 버튼이 있다고 치자. 클래스에서는 버튼이라는 객체가 클릭되어지면 다음화면으로 이동하는 행동을 정의하고 지금 버튼의 이름을 지정하는 상태 등이 동작할 수 있게끔 정의가 되어져있는 설계도의 역할을 한다.

**인스턴스는** 클래스가 메모리에 생성된 상태를 말한다. 클래스로부터 생성된 객체라고도 한다.

힙 메모리에 멤버 변수의 크기에 따라 메모리가 생성된다.



#### 2. 캡슐화

캡슐화는 일반적으로 연관이 있는 변수와 함수를 클래스로 묶는 작업을 말한다. 

캡슐 알약을 먹을 때 어떠한 증상을 완화하기 위해 비슷한 성분의 약품을 캡슐 안에 넣어놓는 것과 비슷하다.

캡슐화에는 정보은닉이라는 것이 존재한다. (외부에서 접근하지 못하게 할 수 있다.)

##### 일반적인 객체지향 언어에서는 접근지정자를 제공

* public
* protected
* private

<img src="C:\Users\user\AppData\Roaming\Typora\typora-user-images\image-20200930135817676.png" alt="image-20200930135817676" style="zoom:130%;" />



#### 3. 상속

상속은 Class의 맴버와 함수를 다른 Class에 물려주거나, 물려 받는 것을 말한다.

* 코드의 재사용이 용이하다. 같은 기능을 또 구현할 필요가 없다.
* 유지보수에 편리성을 제공해준다. 부모 클래스를 한 번만 수정함으로써 자식 클래스를 수정할 필요가 없다. 
* 객체의 다형성을 구현할 수 있다.



#### 4. 다형성

다형성은 같은 다양한 형태로 표현이 가능하다는 의미이다.

*Overriding*

오버라이딩은 상속으로 받은 함수를 그대로 사용하지 않고 새로 만들어서 사용하는 것이다.

역시 코드의 재사용성을 증가시킨다.

*Overloading*

오버로딩은 같은 기능의 함수에 같은 이름을 사용할 수 있어 가독성을 증가시킨다.

하나의 함수에 여러 매개변수를 가질 수 있게 한다.

! 매소드 인자들은 달라야 한다 !



#### 5. 객체지향의 5대 원칙 : SOLID

1. 단일 책임 원칙(Single Responsibility Principle) SRP
2. 개방 폐쇄 원칙(Open Closed Principle) OCP
3. 리스코프 치환 원칙(Liskov Substitution Principle) LSP
4. 인터페이스 분리 원칙(Interface Sergregation Principle) ISP
5. 의존관계 역전 원칙(Dependency Inversion Principle) DIP

##### 5.1 단일 책임 원칙

모든 Class는 하나의 책임만 가지며, 그 책임은 완전히 캡슐화되어야 함을 의미한다.

작성된 Class는 하나의 기능만 가지며, 그 Class가 제공하는 모든 서비스는 하나의 책임을 수행하는 데 집중되어야 한다.

##### 5.2 개방 폐쇄 원칙

클래스, 모듈 함수 등의 소프트웨어 개체는 확장에 대해 열려있어야 하고, 수정에 대해서는 닫혀 있어야 한다는 원칙이다.

수정이 일어나더라도 기존의 구성요소에서는 수정이 일어나지 않아야 하며, 쉽게 확장이 가능하여 재사용을 할 수 있도록 해야 함을 의미한다.

##### 5.3 리스코프 치환 원칙

리스코프 치환 코드는 상속에 대한 개념이다. 즉 부모 Class가 들어갈 자리에 자식 Class를 넣어도 잘 구동되어야 한다는 원칙이다.

! 서브타입은 언제나 자신의 기반타입으로 교체할 수 있어야 한다. 즉 상속받은 서브 Class에서는 그 부모의 정의한 규약을 지켜야 한다 !

##### 5.4 인터페이스 분리 원칙

클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안된다라는 원칙이다.

시스템의 내부 의존성 관계를 느슨하게 하여 리팩토링, 수정, 재배포를 쉽게 할 수 있도록 한다.

##### 5.5 의존성 역전 원칙

```
// 의존성 역전 원칙이 가진 2가지 중요한 요소

1. 상위 모듈은 하위 모듈에 종속되어선 안된다. 둘 다 추상화에 의존해야 한다.
2. 추상화는 세부사항에 의존하지 않는다. 세부사항은 추상화에 의해 달라져야 햔다.
```

자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향을 받지 않게 하는 것이다.